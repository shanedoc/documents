说明：以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。



基础规范
【强制】使用InnoDB存储引擎

说明：InnoDB存储引擎是MySQL默认存储引擎，支持事务和行级锁，并发性能更好，CPU及内存缓存页优化使得资源利用率更高。

【强制】使用utf8字符集，如果有字段需要存储emoji表情之类的，则需要将字段或表设置成utf8mb4

说明：万国码，无需转码，无乱码风险，节省空间，utf8mb4向下兼容utf8。

【强制】数据表、数据字段必须加入中文注释

说明：便于识别表和字段的用途。

【强制】禁止使用存储过程、视图、触发器、Event

说明：高并发大数据的业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”；在并发量大的情况下，数据库很可能成为瓶颈，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”；数据库擅长存储与索引，CPU计算还是交给服务层吧。

【强制】禁止存储大文件或者大照片

说明：大文件和照片存储在文件系统，数据库里存URI

命名规范
【强制】库名、表名、字段名：小写字母，下划线风格，禁止数字开头，禁止两个下划线中间只出现数字，禁止复数名词，必须控制在32个字符以内。

说明：数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

正例：user_config，level3_name

反例：userConfig，level_3_name

【强制】命名中不允许出现MySQL数据库中的保留字。如desc、range、match、delayed等，请参考MySQL官方保留字。

【强制】索引命名格式为：索引类型_字段名。主键索引名为 pk_字段名，唯一索引名为 uk_字段名，普通索引名idx_字段名。

说明：pk_ 即 primary key，uk_ 即 unique key，idx_ 即 index 的简称。

表设计规范
【强制】单实例表数目必须小于500，单表列数目必须小于30

【强制】中间表用于保留中间结果集，名称必须以tmp_开头。备份表用于备份或抓取源表快照，名称必须以bak_开头。中间表和备份表定期清理。

【强制】对于超过100W行的大表进行alter table，必须经过人工（Leader、DBA）审核，并在业务低峰期执行。因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。

【强制】禁止使用外键，如果有外键完整性约束，需要应用程序控制。

说明：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql的性能，甚至会造成死锁。高并发情况下容易造成数据库性能问题，在大数据高并发业务场景下数据库使用以性能优先。

【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint，推荐使用bigint类型，且为auto_increment；(2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片，提升空间和内存的使用。

【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段create_time和最后更新时间字段update_time，并指定int类型（存储时间戳），便于查问题。

【建议】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。

说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。

【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如user_name属性在user_account，user_login_log等表里冗余一份，减少join查询。

【建议】表的命名最好是加上“业务名称_表的作用”。比如：user_config/user_task

字段设计规范

【强制】表中所有字段必须都是NOT NULL属性，可以根据业务需要定义DEFAULT值。

说明：因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。

字段默认值参考如下：

tinyint/int/bigint 类型默认值：0
char/varchar 类型默认值：' ',禁止默认值为NULL
date 类型默认值：'0000-00-00'
time 类型默认值：'00:00:00'
datetime 类型默认值：'0000-00-00 00:00:00'


【强制】存储货币用decimal或int类型，禁止使用float和double

说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。

【建议】不推荐使用blob、text等类型，可以做垂直拆分到子表中。

说明：因为它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。独立出来一张表，用主键来对应，可避免影响其它字段索引效率。

【建议】文本数据尽量用varchar存储。

说明：因为varchar是变长存储，不预先分配存储空间，比char更省空间。MySQL server层规定一行所有文本最多存65535字节，因此在utf8字符集下最多存21844个字符，超过会自动转换为mediumtext字段。而text在utf8字符集下最多存21844个字符，mediumtext最多存2^24/3个字符，longtext最多存2^32个字符。一般建议用varchar类型，字符数不要超过2700。

【建议】不推荐使用enum、set 类型，使用tinyint或smallint代替。

说明：因为它们浪费空间，且枚举值写死了，变更不方便，增加新的enum值要做ddl操作，enum的内部实际存储就是整数。

【建议】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint( 1表示是，0表示否)

说明：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。

【建议】使用varchar(20)存储手机号

说明：涉及到区号或者国家代号，可能出现+-()；手机号不会做数学运算；varchar可以支持模糊查询，例如：like“138%”。

【建议】如果存储的字符串长度几乎相等，使用char定长字符串类型。

【建议】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。

说明：冗余字段应遵循：不是频繁修改的字段，不是varchar超长字段，更不能是text字段。正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。

索引设计规范
【建议】单个表上的索引个数不要超过7个。

说明：索引过多会增加存储开销和增删改的开销。

【强制】单个索引中每个索引记录的长度不能超过64KB。

【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。

说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

【建议】禁止在更新十分频繁、区分度不高的属性上建立索引。

说明：更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能；比如：“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似；

【建议】在建立索引时，多考虑建立组合索引，并把区分度最高的字段放在最前面。比如：可使用select count(distinct userid)计算出来列userid的区分度。

【建议】在排序、分组、取唯一字段上创建索引，经常与其他表进行关联的表，在关联字段上应该建立索引，经常出现在Where子句中的字段，特别是大表的字段，应该建立索引。

【建议】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

SQL 语句规范

【高危】禁用update|delete t1 … where a=XX limit XX;这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上order by PK。

【高危】禁止使用关联子查询，如update t1 set … where name in(select name from user where…);效率极其低下。

【强制】禁用select *，必须指定列。

说明：a)读取不需要的列会增加CPU、IO、NET消耗；b)不能有效的利用覆盖索引；c)使用select *容易在增加或者删除字段后出现程序bug。

【强制】insert语句需指定列，insert into table_name (列1, 列2,...) values (值1, 值2,....)

说明：避免在增加或者删除字段后出现程序bug。

【强制】禁止使用属性隐式转换

说明：select uid from t_user where phone=13812345678 会导致全表扫描，而不能命中phone索引，因为phone是varchar类型，需要添加引号：phone='13812345678'

【强制】禁止负向查询，以及%开头的模糊查询

说明：a)负向查询条件：not、!=、<>、!<、!>、not in、not like等，会导致全表扫描；b)%开头的模糊查询，会导致全表扫描。

【强制】应用程序必须捕获SQL异常，并有相应处理

【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。

【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。

【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时， 保证被关联的字段需要有索引。

说明：即使双表 join 也要注意表索引、SQL 性能。

【建议】禁止大表使用join查询，禁止大表使用子查询

说明：会产生临时表，消耗较多内存与CPU，极大影响数据库性能。

【建议】禁止使用or条件，必须改为in查询

说明：旧版本MySQL的or查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢?

【建议】如果有 order by 的场景，请注意利用索引的有序性。

说明：order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。

正例：where a=? and b=? order by c；索引：a_b_c

反例：索引中有范围查找，那么索引有序性无法利用，如：where a>10 order by b; 索引 a_b 无法排序。

【建议】利用延迟关联或者子查询优化超多分页场景。

说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。

正例：先快速定位需要获取的id段，然后再关联： select a.* from 表1 a, (select id from 表1 where 条件 limit 100000,20 ) b where a.id=b.id

【建议】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。

说明：a)consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据；b)ref 指的是使用普通的索引(normal index)；c)range 对索引进行范围检索。

反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。
